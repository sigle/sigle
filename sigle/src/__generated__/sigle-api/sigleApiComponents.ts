/**
 * Generated by @openapi-codegen
 *
 * @version 0.1.0
 */
import * as reactQuery from '@tanstack/react-query';
import { useSigleApiContext, SigleApiContext } from './sigleApiContext';
import type * as Fetcher from './sigleApiFetcher';
import { sigleApiFetch } from './sigleApiFetcher';
import type * as Schemas from './sigleApiSchemas';

export type AppControllerGetHelloError = Fetcher.ErrorWrapper<undefined>;

export type AppControllerGetHelloVariables = SigleApiContext['fetcherOptions'];

export const fetchAppControllerGetHello = (
  variables: AppControllerGetHelloVariables,
  signal?: AbortSignal
) =>
  sigleApiFetch<undefined, AppControllerGetHelloError, undefined, {}, {}, {}>({
    url: '/health',
    method: 'get',
    ...variables,
    signal,
  });

export const useAppControllerGetHello = <TData = undefined>(
  variables: AppControllerGetHelloVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, AppControllerGetHelloError, TData>,
    'queryKey' | 'queryFn'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useSigleApiContext(options);
  return reactQuery.useQuery<undefined, AppControllerGetHelloError, TData>(
    queryKeyFn({
      path: '/health',
      operationId: 'appControllerGetHello',
      variables,
    }),
    ({ signal }) =>
      fetchAppControllerGetHello({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type UserControllerExploreQueryParams = {
  page: number;
};

export type UserControllerExploreError = Fetcher.ErrorWrapper<undefined>;

export type UserControllerExploreVariables = {
  queryParams: UserControllerExploreQueryParams;
} & SigleApiContext['fetcherOptions'];

/**
 * Return a list of users using Sigle.
 */
export const fetchUserControllerExplore = (
  variables: UserControllerExploreVariables,
  signal?: AbortSignal
) =>
  sigleApiFetch<
    Schemas.ExploreResponse,
    UserControllerExploreError,
    undefined,
    {},
    UserControllerExploreQueryParams,
    {}
  >({ url: '/api/users/explore', method: 'get', ...variables, signal });

/**
 * Return a list of users using Sigle.
 */
export const useUserControllerExplore = <TData = Schemas.ExploreResponse>(
  variables: UserControllerExploreVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.ExploreResponse,
      UserControllerExploreError,
      TData
    >,
    'queryKey' | 'queryFn'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useSigleApiContext(options);
  return reactQuery.useQuery<
    Schemas.ExploreResponse,
    UserControllerExploreError,
    TData
  >(
    queryKeyFn({
      path: '/api/users/explore',
      operationId: 'userControllerExplore',
      variables,
    }),
    ({ signal }) =>
      fetchUserControllerExplore({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type UserControllerGetUserMeError = Fetcher.ErrorWrapper<undefined>;

export type UserControllerGetUserMeVariables =
  SigleApiContext['fetcherOptions'];

/**
 * Return the current logged in user.
 */
export const fetchUserControllerGetUserMe = (
  variables: UserControllerGetUserMeVariables,
  signal?: AbortSignal
) =>
  sigleApiFetch<
    Schemas.UserMeProfileEntity,
    UserControllerGetUserMeError,
    undefined,
    {},
    {},
    {}
  >({ url: '/api/users/me', method: 'get', ...variables, signal });

/**
 * Return the current logged in user.
 */
export const useUserControllerGetUserMe = <TData = Schemas.UserMeProfileEntity>(
  variables: UserControllerGetUserMeVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.UserMeProfileEntity,
      UserControllerGetUserMeError,
      TData
    >,
    'queryKey' | 'queryFn'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useSigleApiContext(options);
  return reactQuery.useQuery<
    Schemas.UserMeProfileEntity,
    UserControllerGetUserMeError,
    TData
  >(
    queryKeyFn({
      path: '/api/users/me',
      operationId: 'userControllerGetUserMe',
      variables,
    }),
    ({ signal }) =>
      fetchUserControllerGetUserMe({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type UserControllerGetUserPathParams = {
  userAddress: string;
};

export type UserControllerGetUserError = Fetcher.ErrorWrapper<undefined>;

export type UserControllerGetUserVariables = {
  pathParams: UserControllerGetUserPathParams;
} & SigleApiContext['fetcherOptions'];

/**
 * Return a user for a given stacks address.
 */
export const fetchUserControllerGetUser = (
  variables: UserControllerGetUserVariables,
  signal?: AbortSignal
) =>
  sigleApiFetch<
    Schemas.UserProfileEntity,
    UserControllerGetUserError,
    undefined,
    {},
    {},
    UserControllerGetUserPathParams
  >({ url: '/api/users/{userAddress}', method: 'get', ...variables, signal });

/**
 * Return a user for a given stacks address.
 */
export const useUserControllerGetUser = <TData = Schemas.UserProfileEntity>(
  variables: UserControllerGetUserVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.UserProfileEntity,
      UserControllerGetUserError,
      TData
    >,
    'queryKey' | 'queryFn'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useSigleApiContext(options);
  return reactQuery.useQuery<
    Schemas.UserProfileEntity,
    UserControllerGetUserError,
    TData
  >(
    queryKeyFn({
      path: '/api/users/{userAddress}',
      operationId: 'userControllerGetUser',
      variables,
    }),
    ({ signal }) =>
      fetchUserControllerGetUser({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type UserControllerGetUserFollowersPathParams = {
  userAddress: string;
};

export type UserControllerGetUserFollowersError =
  Fetcher.ErrorWrapper<undefined>;

export type UserControllerGetUserFollowersResponse = string[];

export type UserControllerGetUserFollowersVariables = {
  pathParams: UserControllerGetUserFollowersPathParams;
} & SigleApiContext['fetcherOptions'];

/**
 * Returns a list of users who are followers of the specified user.
 */
export const fetchUserControllerGetUserFollowers = (
  variables: UserControllerGetUserFollowersVariables,
  signal?: AbortSignal
) =>
  sigleApiFetch<
    UserControllerGetUserFollowersResponse,
    UserControllerGetUserFollowersError,
    undefined,
    {},
    {},
    UserControllerGetUserFollowersPathParams
  >({
    url: '/api/users/{userAddress}/followers',
    method: 'get',
    ...variables,
    signal,
  });

/**
 * Returns a list of users who are followers of the specified user.
 */
export const useUserControllerGetUserFollowers = <
  TData = UserControllerGetUserFollowersResponse
>(
  variables: UserControllerGetUserFollowersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      UserControllerGetUserFollowersResponse,
      UserControllerGetUserFollowersError,
      TData
    >,
    'queryKey' | 'queryFn'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useSigleApiContext(options);
  return reactQuery.useQuery<
    UserControllerGetUserFollowersResponse,
    UserControllerGetUserFollowersError,
    TData
  >(
    queryKeyFn({
      path: '/api/users/{userAddress}/followers',
      operationId: 'userControllerGetUserFollowers',
      variables,
    }),
    ({ signal }) =>
      fetchUserControllerGetUserFollowers(
        { ...fetcherOptions, ...variables },
        signal
      ),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type UserControllerGetUserFollowingPathParams = {
  userAddress: string;
};

export type UserControllerGetUserFollowingError =
  Fetcher.ErrorWrapper<undefined>;

export type UserControllerGetUserFollowingResponse = string[];

export type UserControllerGetUserFollowingVariables = {
  pathParams: UserControllerGetUserFollowingPathParams;
} & SigleApiContext['fetcherOptions'];

/**
 * Returns a list of users the specified user is following.
 */
export const fetchUserControllerGetUserFollowing = (
  variables: UserControllerGetUserFollowingVariables,
  signal?: AbortSignal
) =>
  sigleApiFetch<
    UserControllerGetUserFollowingResponse,
    UserControllerGetUserFollowingError,
    undefined,
    {},
    {},
    UserControllerGetUserFollowingPathParams
  >({
    url: '/api/users/{userAddress}/following',
    method: 'get',
    ...variables,
    signal,
  });

/**
 * Returns a list of users the specified user is following.
 */
export const useUserControllerGetUserFollowing = <
  TData = UserControllerGetUserFollowingResponse
>(
  variables: UserControllerGetUserFollowingVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      UserControllerGetUserFollowingResponse,
      UserControllerGetUserFollowingError,
      TData
    >,
    'queryKey' | 'queryFn'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useSigleApiContext(options);
  return reactQuery.useQuery<
    UserControllerGetUserFollowingResponse,
    UserControllerGetUserFollowingError,
    TData
  >(
    queryKeyFn({
      path: '/api/users/{userAddress}/following',
      operationId: 'userControllerGetUserFollowing',
      variables,
    }),
    ({ signal }) =>
      fetchUserControllerGetUserFollowing(
        { ...fetcherOptions, ...variables },
        signal
      ),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type UserControllerAddFollowError = Fetcher.ErrorWrapper<undefined>;

export type UserControllerAddFollowVariables = {
  body: Schemas.CreateUserFollowDto;
} & SigleApiContext['fetcherOptions'];

/**
 * Allows a user to follow another user.
 */
export const fetchUserControllerAddFollow = (
  variables: UserControllerAddFollowVariables,
  signal?: AbortSignal
) =>
  sigleApiFetch<
    boolean,
    UserControllerAddFollowError,
    Schemas.CreateUserFollowDto,
    {},
    {},
    {}
  >({ url: '/api/users/me/following', method: 'post', ...variables, signal });

/**
 * Allows a user to follow another user.
 */
export const useUserControllerAddFollow = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      boolean,
      UserControllerAddFollowError,
      UserControllerAddFollowVariables
    >,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useSigleApiContext();
  return reactQuery.useMutation<
    boolean,
    UserControllerAddFollowError,
    UserControllerAddFollowVariables
  >(
    (variables: UserControllerAddFollowVariables) =>
      fetchUserControllerAddFollow({ ...fetcherOptions, ...variables }),
    options
  );
};

export type UserControllerRemoveFollowError = Fetcher.ErrorWrapper<undefined>;

export type UserControllerRemoveFollowVariables = {
  body: Schemas.DeleteUserFollowDto;
} & SigleApiContext['fetcherOptions'];

/**
 * Allows a user to unfollow another user.
 */
export const fetchUserControllerRemoveFollow = (
  variables: UserControllerRemoveFollowVariables,
  signal?: AbortSignal
) =>
  sigleApiFetch<
    boolean,
    UserControllerRemoveFollowError,
    Schemas.DeleteUserFollowDto,
    {},
    {},
    {}
  >({ url: '/api/users/me/following', method: 'delete', ...variables, signal });

/**
 * Allows a user to unfollow another user.
 */
export const useUserControllerRemoveFollow = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      boolean,
      UserControllerRemoveFollowError,
      UserControllerRemoveFollowVariables
    >,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useSigleApiContext();
  return reactQuery.useMutation<
    boolean,
    UserControllerRemoveFollowError,
    UserControllerRemoveFollowVariables
  >(
    (variables: UserControllerRemoveFollowVariables) =>
      fetchUserControllerRemoveFollow({ ...fetcherOptions, ...variables }),
    options
  );
};

export type SubscriptionControllerGetUserMeError =
  Fetcher.ErrorWrapper<undefined>;

export type SubscriptionControllerGetUserMeVariables =
  SigleApiContext['fetcherOptions'];

/**
 * Return the current active subscription of the current logged in user.
 */
export const fetchSubscriptionControllerGetUserMe = (
  variables: SubscriptionControllerGetUserMeVariables,
  signal?: AbortSignal
) =>
  sigleApiFetch<
    Schemas.SubscriptionDto,
    SubscriptionControllerGetUserMeError,
    undefined,
    {},
    {},
    {}
  >({ url: '/api/subscriptions', method: 'get', ...variables, signal });

/**
 * Return the current active subscription of the current logged in user.
 */
export const useSubscriptionControllerGetUserMe = <
  TData = Schemas.SubscriptionDto
>(
  variables: SubscriptionControllerGetUserMeVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.SubscriptionDto,
      SubscriptionControllerGetUserMeError,
      TData
    >,
    'queryKey' | 'queryFn'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useSigleApiContext(options);
  return reactQuery.useQuery<
    Schemas.SubscriptionDto,
    SubscriptionControllerGetUserMeError,
    TData
  >(
    queryKeyFn({
      path: '/api/subscriptions',
      operationId: 'subscriptionControllerGetUserMe',
      variables,
    }),
    ({ signal }) =>
      fetchSubscriptionControllerGetUserMe(
        { ...fetcherOptions, ...variables },
        signal
      ),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type SubscriptionControllerSyncSubscriptionWithNftError =
  Fetcher.ErrorWrapper<undefined>;

export type SubscriptionControllerSyncSubscriptionWithNftVariables =
  SigleApiContext['fetcherOptions'];

/**
 * Create or update a creator plus subscription on the current logged in user. A user can only have one active subscription at a time.
 */
export const fetchSubscriptionControllerSyncSubscriptionWithNft = (
  variables: SubscriptionControllerSyncSubscriptionWithNftVariables,
  signal?: AbortSignal
) =>
  sigleApiFetch<
    Schemas.SubscriptionDto,
    SubscriptionControllerSyncSubscriptionWithNftError,
    undefined,
    {},
    {},
    {}
  >({
    url: '/api/subscriptions/syncWithNft',
    method: 'post',
    ...variables,
    signal,
  });

/**
 * Create or update a creator plus subscription on the current logged in user. A user can only have one active subscription at a time.
 */
export const useSubscriptionControllerSyncSubscriptionWithNft = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.SubscriptionDto,
      SubscriptionControllerSyncSubscriptionWithNftError,
      SubscriptionControllerSyncSubscriptionWithNftVariables
    >,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useSigleApiContext();
  return reactQuery.useMutation<
    Schemas.SubscriptionDto,
    SubscriptionControllerSyncSubscriptionWithNftError,
    SubscriptionControllerSyncSubscriptionWithNftVariables
  >(
    (variables: SubscriptionControllerSyncSubscriptionWithNftVariables) =>
      fetchSubscriptionControllerSyncSubscriptionWithNft({
        ...fetcherOptions,
        ...variables,
      }),
    options
  );
};

export type AnalyticsControllerGetReferrersQueryParams = {
  /**
   * The date from which to get the statistics (e.g. 2022-04-01).
   */
  dateFrom: string;
  /**
   * The story id to get the statistics for.
   */
  storyId?: string;
};

export type AnalyticsControllerGetReferrersError =
  Fetcher.ErrorWrapper<undefined>;

export type AnalyticsControllerGetReferrersResponse = Schemas.ReferrerDto[];

export type AnalyticsControllerGetReferrersVariables = {
  queryParams: AnalyticsControllerGetReferrersQueryParams;
} & SigleApiContext['fetcherOptions'];

/**
 * Return the referrer statistics.
 */
export const fetchAnalyticsControllerGetReferrers = (
  variables: AnalyticsControllerGetReferrersVariables,
  signal?: AbortSignal
) =>
  sigleApiFetch<
    AnalyticsControllerGetReferrersResponse,
    AnalyticsControllerGetReferrersError,
    undefined,
    {},
    AnalyticsControllerGetReferrersQueryParams,
    {}
  >({ url: '/api/analytics/referrers', method: 'get', ...variables, signal });

/**
 * Return the referrer statistics.
 */
export const useAnalyticsControllerGetReferrers = <
  TData = AnalyticsControllerGetReferrersResponse
>(
  variables: AnalyticsControllerGetReferrersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      AnalyticsControllerGetReferrersResponse,
      AnalyticsControllerGetReferrersError,
      TData
    >,
    'queryKey' | 'queryFn'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useSigleApiContext(options);
  return reactQuery.useQuery<
    AnalyticsControllerGetReferrersResponse,
    AnalyticsControllerGetReferrersError,
    TData
  >(
    queryKeyFn({
      path: '/api/analytics/referrers',
      operationId: 'analyticsControllerGetReferrers',
      variables,
    }),
    ({ signal }) =>
      fetchAnalyticsControllerGetReferrers(
        { ...fetcherOptions, ...variables },
        signal
      ),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type AnalyticsControllerGetHistoricalQueryParams = {
  /**
   * The date from which to get the statistics (e.g. 2022-04-01).
   */
  dateFrom: string;
  /**
   * The date grouping (e.g. day, month). When day is set the date format is YYYY-MM-DD. When month is set the date format is YYYY-MM.
   */
  dateGrouping: string;
  /**
   * The story id to get the statistics for.
   */
  storyId?: string;
};

export type AnalyticsControllerGetHistoricalError =
  Fetcher.ErrorWrapper<undefined>;

export type AnalyticsControllerGetHistoricalVariables = {
  queryParams: AnalyticsControllerGetHistoricalQueryParams;
} & SigleApiContext['fetcherOptions'];

/**
 * Return the historical statistics.
 */
export const fetchAnalyticsControllerGetHistorical = (
  variables: AnalyticsControllerGetHistoricalVariables,
  signal?: AbortSignal
) =>
  sigleApiFetch<
    Schemas.HistoricalDto,
    AnalyticsControllerGetHistoricalError,
    undefined,
    {},
    AnalyticsControllerGetHistoricalQueryParams,
    {}
  >({ url: '/api/analytics/historical', method: 'get', ...variables, signal });

/**
 * Return the historical statistics.
 */
export const useAnalyticsControllerGetHistorical = <
  TData = Schemas.HistoricalDto
>(
  variables: AnalyticsControllerGetHistoricalVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.HistoricalDto,
      AnalyticsControllerGetHistoricalError,
      TData
    >,
    'queryKey' | 'queryFn'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useSigleApiContext(options);
  return reactQuery.useQuery<
    Schemas.HistoricalDto,
    AnalyticsControllerGetHistoricalError,
    TData
  >(
    queryKeyFn({
      path: '/api/analytics/historical',
      operationId: 'analyticsControllerGetHistorical',
      variables,
    }),
    ({ signal }) =>
      fetchAnalyticsControllerGetHistorical(
        { ...fetcherOptions, ...variables },
        signal
      ),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type SubscribersControllerCreateError = Fetcher.ErrorWrapper<undefined>;

export type SubscribersControllerCreateVariables = {
  body: Schemas.CreateSubscriberDto;
} & SigleApiContext['fetcherOptions'];

/**
 * Create a new email subscriber.
 */
export const fetchSubscribersControllerCreate = (
  variables: SubscribersControllerCreateVariables,
  signal?: AbortSignal
) =>
  sigleApiFetch<
    undefined,
    SubscribersControllerCreateError,
    Schemas.CreateSubscriberDto,
    {},
    {},
    {}
  >({ url: '/api/subscribers', method: 'post', ...variables, signal });

/**
 * Create a new email subscriber.
 */
export const useSubscribersControllerCreate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      SubscribersControllerCreateError,
      SubscribersControllerCreateVariables
    >,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useSigleApiContext();
  return reactQuery.useMutation<
    undefined,
    SubscribersControllerCreateError,
    SubscribersControllerCreateVariables
  >(
    (variables: SubscribersControllerCreateVariables) =>
      fetchSubscribersControllerCreate({ ...fetcherOptions, ...variables }),
    options
  );
};

export type StoriesControllerGetPathParams = {
  storyId: string;
};

export type StoriesControllerGetError = Fetcher.ErrorWrapper<undefined>;

export type StoriesControllerGetVariables = {
  pathParams: StoriesControllerGetPathParams;
} & SigleApiContext['fetcherOptions'];

export const fetchStoriesControllerGet = (
  variables: StoriesControllerGetVariables,
  signal?: AbortSignal
) =>
  sigleApiFetch<
    Schemas.StoryDto,
    StoriesControllerGetError,
    undefined,
    {},
    {},
    StoriesControllerGetPathParams
  >({ url: '/api/stories/{storyId}', method: 'get', ...variables, signal });

export const useStoriesControllerGet = <TData = Schemas.StoryDto>(
  variables: StoriesControllerGetVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.StoryDto,
      StoriesControllerGetError,
      TData
    >,
    'queryKey' | 'queryFn'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useSigleApiContext(options);
  return reactQuery.useQuery<
    Schemas.StoryDto,
    StoriesControllerGetError,
    TData
  >(
    queryKeyFn({
      path: '/api/stories/{storyId}',
      operationId: 'storiesControllerGet',
      variables,
    }),
    ({ signal }) =>
      fetchStoriesControllerGet({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type StoriesControllerSendTestError = Fetcher.ErrorWrapper<undefined>;

export type StoriesControllerSendTestVariables = {
  body: Schemas.SendTestStoryDto;
} & SigleApiContext['fetcherOptions'];

export const fetchStoriesControllerSendTest = (
  variables: StoriesControllerSendTestVariables,
  signal?: AbortSignal
) =>
  sigleApiFetch<
    undefined,
    StoriesControllerSendTestError,
    Schemas.SendTestStoryDto,
    {},
    {},
    {}
  >({ url: '/api/stories/send-test', method: 'post', ...variables, signal });

export const useStoriesControllerSendTest = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      StoriesControllerSendTestError,
      StoriesControllerSendTestVariables
    >,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useSigleApiContext();
  return reactQuery.useMutation<
    undefined,
    StoriesControllerSendTestError,
    StoriesControllerSendTestVariables
  >(
    (variables: StoriesControllerSendTestVariables) =>
      fetchStoriesControllerSendTest({ ...fetcherOptions, ...variables }),
    options
  );
};

export type StoriesControllerPublishError = Fetcher.ErrorWrapper<undefined>;

export type StoriesControllerPublishVariables = {
  body: Schemas.PublishStoryDto;
} & SigleApiContext['fetcherOptions'];

export const fetchStoriesControllerPublish = (
  variables: StoriesControllerPublishVariables,
  signal?: AbortSignal
) =>
  sigleApiFetch<
    undefined,
    StoriesControllerPublishError,
    Schemas.PublishStoryDto,
    {},
    {},
    {}
  >({ url: '/api/stories/publish', method: 'post', ...variables, signal });

export const useStoriesControllerPublish = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      StoriesControllerPublishError,
      StoriesControllerPublishVariables
    >,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useSigleApiContext();
  return reactQuery.useMutation<
    undefined,
    StoriesControllerPublishError,
    StoriesControllerPublishVariables
  >(
    (variables: StoriesControllerPublishVariables) =>
      fetchStoriesControllerPublish({ ...fetcherOptions, ...variables }),
    options
  );
};

export type StoriesControllerUnpublishError = Fetcher.ErrorWrapper<undefined>;

export type StoriesControllerUnpublishVariables = {
  body: Schemas.UnpublishStoryDto;
} & SigleApiContext['fetcherOptions'];

export const fetchStoriesControllerUnpublish = (
  variables: StoriesControllerUnpublishVariables,
  signal?: AbortSignal
) =>
  sigleApiFetch<
    undefined,
    StoriesControllerUnpublishError,
    Schemas.UnpublishStoryDto,
    {},
    {},
    {}
  >({ url: '/api/stories/unpublish', method: 'post', ...variables, signal });

export const useStoriesControllerUnpublish = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      StoriesControllerUnpublishError,
      StoriesControllerUnpublishVariables
    >,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useSigleApiContext();
  return reactQuery.useMutation<
    undefined,
    StoriesControllerUnpublishError,
    StoriesControllerUnpublishVariables
  >(
    (variables: StoriesControllerUnpublishVariables) =>
      fetchStoriesControllerUnpublish({ ...fetcherOptions, ...variables }),
    options
  );
};

export type StoriesControllerDeleteError = Fetcher.ErrorWrapper<undefined>;

export type StoriesControllerDeleteVariables = {
  body: Schemas.UnpublishStoryDto;
} & SigleApiContext['fetcherOptions'];

export const fetchStoriesControllerDelete = (
  variables: StoriesControllerDeleteVariables,
  signal?: AbortSignal
) =>
  sigleApiFetch<
    undefined,
    StoriesControllerDeleteError,
    Schemas.UnpublishStoryDto,
    {},
    {},
    {}
  >({ url: '/api/stories/delete', method: 'post', ...variables, signal });

export const useStoriesControllerDelete = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      StoriesControllerDeleteError,
      StoriesControllerDeleteVariables
    >,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useSigleApiContext();
  return reactQuery.useMutation<
    undefined,
    StoriesControllerDeleteError,
    StoriesControllerDeleteVariables
  >(
    (variables: StoriesControllerDeleteVariables) =>
      fetchStoriesControllerDelete({ ...fetcherOptions, ...variables }),
    options
  );
};

export type NewslettersControllerGetError = Fetcher.ErrorWrapper<undefined>;

export type NewslettersControllerGetVariables =
  SigleApiContext['fetcherOptions'];

export const fetchNewslettersControllerGet = (
  variables: NewslettersControllerGetVariables,
  signal?: AbortSignal
) =>
  sigleApiFetch<
    Schemas.NewsletterEntity,
    NewslettersControllerGetError,
    undefined,
    {},
    {},
    {}
  >({ url: '/api/newsletters', method: 'get', ...variables, signal });

export const useNewslettersControllerGet = <TData = Schemas.NewsletterEntity>(
  variables: NewslettersControllerGetVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.NewsletterEntity,
      NewslettersControllerGetError,
      TData
    >,
    'queryKey' | 'queryFn'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useSigleApiContext(options);
  return reactQuery.useQuery<
    Schemas.NewsletterEntity,
    NewslettersControllerGetError,
    TData
  >(
    queryKeyFn({
      path: '/api/newsletters',
      operationId: 'newslettersControllerGet',
      variables,
    }),
    ({ signal }) =>
      fetchNewslettersControllerGet(
        { ...fetcherOptions, ...variables },
        signal
      ),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type NewslettersControllerUpdateError = Fetcher.ErrorWrapper<undefined>;

export type NewslettersControllerUpdateVariables = {
  body: Schemas.UpdateNewsletterDto;
} & SigleApiContext['fetcherOptions'];

export const fetchNewslettersControllerUpdate = (
  variables: NewslettersControllerUpdateVariables,
  signal?: AbortSignal
) =>
  sigleApiFetch<
    undefined,
    NewslettersControllerUpdateError,
    Schemas.UpdateNewsletterDto,
    {},
    {},
    {}
  >({ url: '/api/newsletters', method: 'post', ...variables, signal });

export const useNewslettersControllerUpdate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      NewslettersControllerUpdateError,
      NewslettersControllerUpdateVariables
    >,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useSigleApiContext();
  return reactQuery.useMutation<
    undefined,
    NewslettersControllerUpdateError,
    NewslettersControllerUpdateVariables
  >(
    (variables: NewslettersControllerUpdateVariables) =>
      fetchNewslettersControllerUpdate({ ...fetcherOptions, ...variables }),
    options
  );
};

export type NewslettersControllerGetContactsListsError =
  Fetcher.ErrorWrapper<undefined>;

export type NewslettersControllerGetContactsListsResponse =
  Schemas.ContactsListsEntity[];

export type NewslettersControllerGetContactsListsVariables =
  SigleApiContext['fetcherOptions'];

export const fetchNewslettersControllerGetContactsLists = (
  variables: NewslettersControllerGetContactsListsVariables,
  signal?: AbortSignal
) =>
  sigleApiFetch<
    NewslettersControllerGetContactsListsResponse,
    NewslettersControllerGetContactsListsError,
    undefined,
    {},
    {},
    {}
  >({
    url: '/api/newsletters/contacts-lists',
    method: 'get',
    ...variables,
    signal,
  });

export const useNewslettersControllerGetContactsLists = <
  TData = NewslettersControllerGetContactsListsResponse
>(
  variables: NewslettersControllerGetContactsListsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      NewslettersControllerGetContactsListsResponse,
      NewslettersControllerGetContactsListsError,
      TData
    >,
    'queryKey' | 'queryFn'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useSigleApiContext(options);
  return reactQuery.useQuery<
    NewslettersControllerGetContactsListsResponse,
    NewslettersControllerGetContactsListsError,
    TData
  >(
    queryKeyFn({
      path: '/api/newsletters/contacts-lists',
      operationId: 'newslettersControllerGetContactsLists',
      variables,
    }),
    ({ signal }) =>
      fetchNewslettersControllerGetContactsLists(
        { ...fetcherOptions, ...variables },
        signal
      ),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type NewslettersControllerUpdateContactsListError =
  Fetcher.ErrorWrapper<undefined>;

export type NewslettersControllerUpdateContactsListVariables = {
  body: Schemas.UpdateContactsListDto;
} & SigleApiContext['fetcherOptions'];

export const fetchNewslettersControllerUpdateContactsList = (
  variables: NewslettersControllerUpdateContactsListVariables,
  signal?: AbortSignal
) =>
  sigleApiFetch<
    undefined,
    NewslettersControllerUpdateContactsListError,
    Schemas.UpdateContactsListDto,
    {},
    {},
    {}
  >({
    url: '/api/newsletters/contacts-lists',
    method: 'post',
    ...variables,
    signal,
  });

export const useNewslettersControllerUpdateContactsList = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      NewslettersControllerUpdateContactsListError,
      NewslettersControllerUpdateContactsListVariables
    >,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useSigleApiContext();
  return reactQuery.useMutation<
    undefined,
    NewslettersControllerUpdateContactsListError,
    NewslettersControllerUpdateContactsListVariables
  >(
    (variables: NewslettersControllerUpdateContactsListVariables) =>
      fetchNewslettersControllerUpdateContactsList({
        ...fetcherOptions,
        ...variables,
      }),
    options
  );
};

export type NewslettersControllerSyncSenderError =
  Fetcher.ErrorWrapper<undefined>;

export type NewslettersControllerSyncSenderVariables =
  SigleApiContext['fetcherOptions'];

export const fetchNewslettersControllerSyncSender = (
  variables: NewslettersControllerSyncSenderVariables,
  signal?: AbortSignal
) =>
  sigleApiFetch<
    undefined,
    NewslettersControllerSyncSenderError,
    undefined,
    {},
    {},
    {}
  >({ url: '/api/newsletters/sender', method: 'post', ...variables, signal });

export const useNewslettersControllerSyncSender = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      NewslettersControllerSyncSenderError,
      NewslettersControllerSyncSenderVariables
    >,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useSigleApiContext();
  return reactQuery.useMutation<
    undefined,
    NewslettersControllerSyncSenderError,
    NewslettersControllerSyncSenderVariables
  >(
    (variables: NewslettersControllerSyncSenderVariables) =>
      fetchNewslettersControllerSyncSender({ ...fetcherOptions, ...variables }),
    options
  );
};

export type EmailVerificationControllerAddEmailError =
  Fetcher.ErrorWrapper<undefined>;

export type EmailVerificationControllerAddEmailVariables = {
  body: Schemas.AddEmailDto;
} & SigleApiContext['fetcherOptions'];

/**
 * Add an email address for the authenticated user. Send an email to the user with a verification link.
 */
export const fetchEmailVerificationControllerAddEmail = (
  variables: EmailVerificationControllerAddEmailVariables,
  signal?: AbortSignal
) =>
  sigleApiFetch<
    boolean,
    EmailVerificationControllerAddEmailError,
    Schemas.AddEmailDto,
    {},
    {},
    {}
  >({
    url: '/api/email-verification/add',
    method: 'post',
    ...variables,
    signal,
  });

/**
 * Add an email address for the authenticated user. Send an email to the user with a verification link.
 */
export const useEmailVerificationControllerAddEmail = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      boolean,
      EmailVerificationControllerAddEmailError,
      EmailVerificationControllerAddEmailVariables
    >,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useSigleApiContext();
  return reactQuery.useMutation<
    boolean,
    EmailVerificationControllerAddEmailError,
    EmailVerificationControllerAddEmailVariables
  >(
    (variables: EmailVerificationControllerAddEmailVariables) =>
      fetchEmailVerificationControllerAddEmail({
        ...fetcherOptions,
        ...variables,
      }),
    options
  );
};

export type EmailVerificationControllerVerifyEmailError =
  Fetcher.ErrorWrapper<undefined>;

export type EmailVerificationControllerVerifyEmailVariables = {
  body: Schemas.VerifyEmailDto;
} & SigleApiContext['fetcherOptions'];

/**
 * Verify a user email address.
 */
export const fetchEmailVerificationControllerVerifyEmail = (
  variables: EmailVerificationControllerVerifyEmailVariables,
  signal?: AbortSignal
) =>
  sigleApiFetch<
    boolean,
    EmailVerificationControllerVerifyEmailError,
    Schemas.VerifyEmailDto,
    {},
    {},
    {}
  >({
    url: '/api/email-verification/verify',
    method: 'post',
    ...variables,
    signal,
  });

/**
 * Verify a user email address.
 */
export const useEmailVerificationControllerVerifyEmail = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      boolean,
      EmailVerificationControllerVerifyEmailError,
      EmailVerificationControllerVerifyEmailVariables
    >,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useSigleApiContext();
  return reactQuery.useMutation<
    boolean,
    EmailVerificationControllerVerifyEmailError,
    EmailVerificationControllerVerifyEmailVariables
  >(
    (variables: EmailVerificationControllerVerifyEmailVariables) =>
      fetchEmailVerificationControllerVerifyEmail({
        ...fetcherOptions,
        ...variables,
      }),
    options
  );
};

export type EmailVerificationControllerResendEmailError =
  Fetcher.ErrorWrapper<undefined>;

export type EmailVerificationControllerResendEmailVariables =
  SigleApiContext['fetcherOptions'];

/**
 * Resend link to verify a user email address.
 */
export const fetchEmailVerificationControllerResendEmail = (
  variables: EmailVerificationControllerResendEmailVariables,
  signal?: AbortSignal
) =>
  sigleApiFetch<
    boolean,
    EmailVerificationControllerResendEmailError,
    undefined,
    {},
    {},
    {}
  >({
    url: '/api/email-verification/resend',
    method: 'post',
    ...variables,
    signal,
  });

/**
 * Resend link to verify a user email address.
 */
export const useEmailVerificationControllerResendEmail = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      boolean,
      EmailVerificationControllerResendEmailError,
      EmailVerificationControllerResendEmailVariables
    >,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useSigleApiContext();
  return reactQuery.useMutation<
    boolean,
    EmailVerificationControllerResendEmailError,
    EmailVerificationControllerResendEmailVariables
  >(
    (variables: EmailVerificationControllerResendEmailVariables) =>
      fetchEmailVerificationControllerResendEmail({
        ...fetcherOptions,
        ...variables,
      }),
    options
  );
};

export type QueryOperation =
  | {
      path: '/health';
      operationId: 'appControllerGetHello';
      variables: AppControllerGetHelloVariables;
    }
  | {
      path: '/api/users/explore';
      operationId: 'userControllerExplore';
      variables: UserControllerExploreVariables;
    }
  | {
      path: '/api/users/me';
      operationId: 'userControllerGetUserMe';
      variables: UserControllerGetUserMeVariables;
    }
  | {
      path: '/api/users/{userAddress}';
      operationId: 'userControllerGetUser';
      variables: UserControllerGetUserVariables;
    }
  | {
      path: '/api/users/{userAddress}/followers';
      operationId: 'userControllerGetUserFollowers';
      variables: UserControllerGetUserFollowersVariables;
    }
  | {
      path: '/api/users/{userAddress}/following';
      operationId: 'userControllerGetUserFollowing';
      variables: UserControllerGetUserFollowingVariables;
    }
  | {
      path: '/api/subscriptions';
      operationId: 'subscriptionControllerGetUserMe';
      variables: SubscriptionControllerGetUserMeVariables;
    }
  | {
      path: '/api/analytics/referrers';
      operationId: 'analyticsControllerGetReferrers';
      variables: AnalyticsControllerGetReferrersVariables;
    }
  | {
      path: '/api/analytics/historical';
      operationId: 'analyticsControllerGetHistorical';
      variables: AnalyticsControllerGetHistoricalVariables;
    }
  | {
      path: '/api/stories/{storyId}';
      operationId: 'storiesControllerGet';
      variables: StoriesControllerGetVariables;
    }
  | {
      path: '/api/newsletters';
      operationId: 'newslettersControllerGet';
      variables: NewslettersControllerGetVariables;
    }
  | {
      path: '/api/newsletters/contacts-lists';
      operationId: 'newslettersControllerGetContactsLists';
      variables: NewslettersControllerGetContactsListsVariables;
    };
